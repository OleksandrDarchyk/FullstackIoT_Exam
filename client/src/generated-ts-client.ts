//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ActionsHistoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getActions(turbineId: string, limit: number | undefined): Promise<OperatorActionDto[]> {
        let url_ = this.baseUrl + "/api/turbines/{turbineId}/actions?";
        if (turbineId === undefined || turbineId === null)
            throw new globalThis.Error("The parameter 'turbineId' must be defined.");
        url_ = url_.replace("{turbineId}", encodeURIComponent("" + turbineId));
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActions(_response);
        });
    }

    protected processGetActions(response: Response): Promise<OperatorActionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OperatorActionDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperatorActionDto[]>(null as any);
    }
}

export class AlertRealtimeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAlerts(connectionId: string | undefined, turbineId: string | null | undefined): Promise<RealtimeListenResponseOfListOfAlert> {
        let url_ = this.baseUrl + "/GetAlerts?";
        if (connectionId === null)
            throw new globalThis.Error("The parameter 'connectionId' cannot be null.");
        else if (connectionId !== undefined)
            url_ += "connectionId=" + encodeURIComponent("" + connectionId) + "&";
        if (turbineId !== undefined && turbineId !== null)
            url_ += "turbineId=" + encodeURIComponent("" + turbineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAlerts(_response);
        });
    }

    protected processGetAlerts(response: Response): Promise<RealtimeListenResponseOfListOfAlert> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RealtimeListenResponseOfListOfAlert;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RealtimeListenResponseOfListOfAlert>(null as any);
    }
}

export class AlertsHistoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAlerts(turbineId: string, limit: number | undefined): Promise<AlertDto[]> {
        let url_ = this.baseUrl + "/api/turbines/{turbineId}/alerts?";
        if (turbineId === undefined || turbineId === null)
            throw new globalThis.Error("The parameter 'turbineId' must be defined.");
        url_ = url_.replace("{turbineId}", encodeURIComponent("" + turbineId));
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAlerts(_response);
        });
    }

    protected processGetAlerts(response: Response): Promise<AlertDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AlertDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AlertDto[]>(null as any);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    register(dto: RegisterRequestDto): Promise<AuthResponseDto> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<AuthResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthResponseDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResponseDto>(null as any);
    }

    login(dto: LoginRequestDto): Promise<AuthResponseDto> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AuthResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthResponseDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResponseDto>(null as any);
    }
}

export class SseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    connect(): Promise<void> {
        let url_ = this.baseUrl + "/sse";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnect(_response);
        });
    }

    protected processConnect(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TelemetryHistoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getHistory(turbineId: string, limit: number | undefined): Promise<TelemetryPointDto[]> {
        let url_ = this.baseUrl + "/api/turbines/{turbineId}/telemetry?";
        if (turbineId === undefined || turbineId === null)
            throw new globalThis.Error("The parameter 'turbineId' must be defined.");
        url_ = url_.replace("{turbineId}", encodeURIComponent("" + turbineId));
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHistory(_response);
        });
    }

    protected processGetHistory(response: Response): Promise<TelemetryPointDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TelemetryPointDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TelemetryPointDto[]>(null as any);
    }
}

export class TelemetryRealtimeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getTelemetry(connectionId: string | undefined, turbineId: string | undefined): Promise<RealtimeListenResponseOfListOfTelemetryRecord> {
        let url_ = this.baseUrl + "/GetTelemetry?";
        if (connectionId === null)
            throw new globalThis.Error("The parameter 'connectionId' cannot be null.");
        else if (connectionId !== undefined)
            url_ += "connectionId=" + encodeURIComponent("" + connectionId) + "&";
        if (turbineId === null)
            throw new globalThis.Error("The parameter 'turbineId' cannot be null.");
        else if (turbineId !== undefined)
            url_ += "turbineId=" + encodeURIComponent("" + turbineId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTelemetry(_response);
        });
    }

    protected processGetTelemetry(response: Response): Promise<RealtimeListenResponseOfListOfTelemetryRecord> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RealtimeListenResponseOfListOfTelemetryRecord;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RealtimeListenResponseOfListOfTelemetryRecord>(null as any);
    }
}

export class TurbineCommandClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    sendCommand(turbineId: string, command: any): Promise<void> {
        let url_ = this.baseUrl + "/api/turbines/{turbineId}/command";
        if (turbineId === undefined || turbineId === null)
            throw new globalThis.Error("The parameter 'turbineId' must be defined.");
        url_ = url_.replace("{turbineId}", encodeURIComponent("" + turbineId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendCommand(_response);
        });
    }

    protected processSendCommand(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TurbinesReadClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(): Promise<TurbineDto[]> {
        let url_ = this.baseUrl + "/api/turbines";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<TurbineDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TurbineDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TurbineDto[]>(null as any);
    }
}

export interface OperatorActionDto {
    id?: string;
    turbineId?: string;
    requestedAt?: string;
    action?: string;
    status?: string;
    validationError?: string | undefined;
}

/** Returned by subscribe endpoints so the client knows which SSE group to listen on. */
export interface RealtimeListenResponse {
    group?: string;
}

/** Returned by subscribe endpoints with initial data. The client receives the current state immediately and knows which SSE group to listen on for subsequent updates. */
export interface RealtimeListenResponseOfListOfAlert extends RealtimeListenResponse {
    data?: Alert[] | undefined;
}

export interface Alert {
    id?: number;
    farmId?: string;
    turbineId?: string | undefined;
    ts?: string;
    receivedAt?: string;
    severity?: string;
    message?: string;
    payloadJson?: string;
    farm?: Farm;
    turbine?: Turbine | undefined;
}

export interface Farm {
    id?: string;
    name?: string | undefined;
    createdAt?: string;
    turbines?: Turbine[];
    alerts?: Alert[];
}

export interface Turbine {
    farmId?: string;
    turbineId?: string;
    name?: string | undefined;
    location?: string | undefined;
    createdAt?: string;
    farm?: Farm;
    telemetry?: TelemetryRecord[];
    alerts?: Alert[];
    operatorActions?: OperatorAction[];
}

export interface TelemetryRecord {
    id?: number;
    farmId?: string;
    turbineId?: string;
    ts?: string;
    receivedAt?: string;
    windSpeed?: number | undefined;
    windDirection?: number | undefined;
    ambientTemperature?: number | undefined;
    rotorSpeed?: number | undefined;
    powerOutput?: number | undefined;
    nacelleDirection?: number | undefined;
    bladePitch?: number | undefined;
    generatorTemp?: number | undefined;
    gearboxTemp?: number | undefined;
    vibration?: number | undefined;
    status?: string | undefined;
    payloadJson?: string;
    turbine?: Turbine;
}

export interface OperatorAction {
    id?: string;
    farmId?: string;
    turbineId?: string;
    userId?: string;
    action?: string;
    payloadJson?: string;
    requestedAt?: string;
    status?: string;
    validationError?: string | undefined;
    user?: AppUser;
    turbine?: Turbine;
}

export interface AppUser {
    id?: string;
    username?: string;
    passwordHash?: string;
    passwordSalt?: string;
    role?: string;
    createdAt?: string;
    operatorActions?: OperatorAction[];
}

export interface AlertDto {
    id?: number;
    turbineId?: string | undefined;
    ts?: string;
    severity?: string;
    message?: string;
}

export interface AuthResponseDto {
    userId?: string;
    username?: string;
    role?: string;
    token?: string;
}

export interface RegisterRequestDto {
    username?: string;
    password?: string;
}

export interface LoginRequestDto {
    username?: string;
    password?: string;
}

export interface TelemetryPointDto {
    turbineId?: string;
    ts?: string;
    windSpeed?: number | undefined;
    powerOutput?: number | undefined;
    rotorSpeed?: number | undefined;
    generatorTemp?: number | undefined;
    gearboxTemp?: number | undefined;
    vibration?: number | undefined;
    bladePitch?: number | undefined;
    status?: string | undefined;
}

/** Returned by subscribe endpoints with initial data. The client receives the current state immediately and knows which SSE group to listen on for subsequent updates. */
export interface RealtimeListenResponseOfListOfTelemetryRecord extends RealtimeListenResponse {
    data?: TelemetryRecord[] | undefined;
}

export interface TurbineDto {
    turbineId?: string;
    name?: string | undefined;
    location?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}